
@inproceedings{rusli_designing_2017,
  location = {{Bandung, Indonesia}},
  title = {Designing an Enterprise Architecture ({{EA}}) Based on {{TOGAF ADM}} and {{MIPI}}},
  isbn = {978-1-5386-3100-3},
  url = {http://ieeexplore.ieee.org/document/8267915/},
  doi = {10.1109/ICITSI.2017.8267915},
  eventtitle = {2017 {{International Conference}} on {{Information Technology Systems}} and {{Innovation}} ({{ICITSI}})},
  booktitle = {2017 {{International Conference}} on {{Information Technology Systems}} and {{Innovation}} ({{ICITSI}})},
  publisher = {{IEEE}},
  urldate = {2019-01-05},
  date = {2017-10},
  pages = {38-43},
  author = {Rusli, Dede and Bandung, Yoanes},
  file = {/home/patryk/Zotero/storage/TN3BLKVT/Rusli et Bandung - 2017 - Designing an enterprise architecture (EA) based on.pdf}
}

@article{qurratuaini_designing_2018,
  title = {Designing Enterprise Architecture Based on {{TOGAF}} 9.1 Framework},
  volume = {403},
  doi = {10.1088/1757-899X/403/1/012065},
  abstract = {The development and utilization of information technology in everyday life continues to grow rapidly within the passage of time. As a result, organizations or companies have many choices in determining the information technology to be applied in their organizations or companies. To ensure that information technology solutions implemented by enterprises are able to help companies properly solve their problems, the solution must take into consideration the culture and condition of the enterprises and the capabilities of information technology held at that time. The solution should also be able to integrate the company's data and systems, take advantage of existing enterprises capabilities, and ensure that the enterprises' resources are ready to transform from the current state to the target state. Based on the requirements statement, the right information technology solution to be applied to enterprises is enterprise architecture. From the existing enterprise architecture frameworks, TOGAF framework is chosen as the framework that will be used in this paper by reason of the completeness of the process, integrated processes, and flexibility. Expected results from the design of enterprise architecture in this paper is the target of enterprise architecture to be achieved, gap analysis between the initial architecture and targets, as well as project roadmap to assist enterprises in achieving the desired target and solve their current problems. In this paper, the design of enterprise architecture by applying TOGAF framework will be done on one of state-owned enterprises (BUMN) in Indonesia.},
  journaltitle = {IOP Conference Series: Materials Science and Engineering},
  shortjournal = {IOP Conference Series: Materials Science and Engineering},
  date = {2018-10-09},
  pages = {012065},
  author = {Qurratuaini, H},
  file = {/home/patryk/Zotero/storage/AW82MD7W/Qurratuaini - 2018 - Designing enterprise architecture based on TOGAF 9.pdf}
}

@article{laumann_enterprise_2018,
  langid = {english},
  title = {Enterprise {{Architecture}} for a {{Facilitated Transformation}} from a {{Linear}} to a {{Circular Economy}}},
  volume = {10},
  issn = {2071-1050},
  url = {http://www.mdpi.com/2071-1050/10/11/3882},
  doi = {10.3390/su10113882},
  abstract = {The circular economy is central to the agenda of responsible production and consumption with propositions for the conservation of natural resources and a broader understanding of the obligations of enterprises and product developers. The circular economy is challenging traditional operating models of enterprises due to the need to manage larger parts of the product life cycle and value chains. A linear economy will normally address a smaller part of the life cycle. The operating models of companies are supported with respect to information and technology with an enterprise architecture model. This article examines the necessary steps for analysing and designing the enterprise architecture model, aiming to facilitate the transformation of an enterprise from operating in a linear to operating in a circular economy model. The fundamentals and requirements of the circular economy enterprise are extracted to isolate the design requirements for the operating model, entailing cross-enterprise collaboration, traceability, and a broader value chain understanding. Furthermore, it conceptualizes enterprise architecture and its role and importance in connecting business strategies and operating technologies. This article develops an enterprise architecture framework, named the Circular Economy Enterprise Architecture Framework (CEEAF), which can form and support the effort of transitioning companies or be embedded into existing enterprise architecture frameworks. The CEEAF differs from traditional enterprise architecture frameworks by addressing the broader responsibility of the enterprise, the extended enterprise, the elimination of end-of-life perspectives and mind-sets, and the capabilities of the individual enterprise and its design activities.},
  number = {11},
  journaltitle = {Sustainability},
  urldate = {2019-01-05},
  date = {2018-10-25},
  pages = {3882},
  author = {Laumann, Felix and Tambo, Torben},
  file = {/home/patryk/Zotero/storage/924PTLM4/Laumann et Tambo - 2018 - Enterprise Architecture for a Facilitated Transfor.pdf}
}

@online{oliveira_formal_1997,
  title = {Formal {{Methods}}: {{The CAMILA Perspective}}},
  url = {http://www4.di.uminho.pt/~jno/html/cam-tcp.html},
  urldate = {2019-01-14},
  date = {1997-03-21},
  author = {Oliveira, José Nuno},
  file = {/home/patryk/Zotero/storage/MYITY7CY/cam-tcp.html}
}

@online{the_open_group_archimate_2017,
  title = {{{ArchiMate}}® 3.0.1 {{Specification}}},
  url = {http://pubs.opengroup.org/architecture/archimate3-doc/chap01.html#_Toc489945950},
  journaltitle = {The Open Group},
  urldate = {2019-01-14},
  date = {2017},
  author = {{The Open Group}},
  file = {/home/patryk/Zotero/storage/4WZB837J/chap01.html}
}

@book{josey_archimate_2017,
  langid = {dutch},
  title = {ArchiMate® 3.0.1 - A Pocket Guide},
  isbn = {978-94-018-0233-8},
  abstract = {ArchiMate®, an Open Group Standard, is an open and independent modeling language for Enterprise Architecture that is supported by different tool vendors and consulting firms. The ArchiMate language enables Enterprise Architects to describe, analyze, and visualize the relationships among architecture domains in an unambiguous way.This Pocket Guide is based on the ArchiMate® 3.0.1 Specification. It gives a concise introduction to the ArchiMate language. What’s more, it’s authoritative with material derived from the official ArchiMate documentation.Topics covered include:• A high-level introduction to the ArchiMate Specification and its relationship to Enterprise Architecture• The high-level structure of the ArchiMate language, including an introduction to layering, and the ArchiMate Framework• The Generic Metamodel for the language• The relationships that the ArchiMate language includes to model the links between elements• The Motivation Elements, which includes concepts such as goal, principle, and requirement• The Strategy Elements, which includes concepts such as resource, capability, and course of action• The Business Layer, which includes the modeling concepts relevant in the business domain• The Application Layer, which includes modeling concepts relevant for software applications• The Technology Layer, which includes modeling concepts relevant for system software applications and infrastructure• The Physical Elements, which include concepts relevant for the modeling of physical concepts like machines and physical installations• The relationships between different layers of the language• The Implementation and Migration Elements, which include concepts to support modeling Enterprise Architecture-enabled transformation• A summary of the major changes from ArchiMate 2.1 to ArchiMate 3• A Glossary of terms},
  pagetotal = {127},
  publisher = {{Van Haren}},
  date = {2017-10-03},
  keywords = {Education / General,Education / Organizations & Institutions,Education / Standards (incl. Common Core),Education / Teaching Methods & Materials / General,Education / Training & Certification},
  author = {Josey, Andrew},
  eprinttype = {googlebooks}
}

@article{josey_introduction_2016,
  langid = {english},
  title = {An {{Introduction}} to the {{ArchiMate}}® 3.0 {{Specification}}},
  date = {2016-06},
  pages = {20},
  author = {Josey, Andrew and Lankhorst, Marc and Band, Iver and Jonkers, Henk and Quartel, Dick},
  file = {/home/patryk/Zotero/storage/RBJ3GQ96/Josey et al. - An Introduction to the ArchiMate® 3.0 Specificatio.pdf}
}

@book{josey_archimate_2012,
  title = {Archimate 2.0 - {{A Pocket Guide}}},
  isbn = {978-90-8753-696-1},
  abstract = {ArchiMate, an Open Group Standard, is an open and independent modeling language for Enterprise Architecture that is supported by different tool vendors and consulting firms. ArchiMate provides instruments to enable enterprise architects to describe, analyze, and visualize the relationships among business domains in an unambiguous way. This Pocket Guide is based on ArchiMate 2.0. It gives a concise introduction to ArchiMate. What s more, it s authoritative with material derived from the official ArchiMate documentation. Topics covered include: A high-level introduction to ArchiMate and its relationship to Enterprise Architecture The Business Layer, which includes the modeling concepts relevant in the business domain The Application Layer, which includes modeling concepts relevant for software applications The Technology Layer, which includes modeling concepts relevant for system software applications and infrastructure The relationships that the ArchiMate language includes to model the links between elements, and also the relationships to model the cross-layer dependencies The Motivation Extension The Implementation and Migration Extension The ArchiMate framework for defining and classifying ArchiMate viewpoints, including a summary of all the viewpoints in the ArchiMate 2.0 Standard The ArchiSurance Case Study, a fictitious example developed to illustrate use of the Modeling language in the context of the TOGAF Framework},
  publisher = {{Van Haren Publishing}},
  date = {2012},
  author = {Josey, Andrew},
  file = {/home/patryk/Zotero/storage/X7MGRDL5/ArchiMate® 2.0 – A Pocket Guide.pdf}
}

@online{leks_pare_2010,
  langid = {polish},
  title = {Parę słów o architekturze korporacyjnej | ArchiReq | Architektura korporacyjna w praktyce},
  url = {http://archireq.pl/pl/pare-slow-o-architekturze-korporacyjnej/},
  abstract = {ArchiReq | Architektura korporacyjna w praktyce},
  urldate = {2019-01-14},
  date = {2010-05-23},
  author = {Leks, Maciej},
  file = {/home/patryk/Zotero/storage/BDPMCMIN/pare-slow-o-architekturze-korporacyjnej.html}
}

@online{fowler_dsl_nodate,
  title = {{{DSL Patterns}}},
  url = {https://martinfowler.com/dslCatalog/},
  urldate = {2019-01-15},
  author = {Fowler, Martin},
  file = {/home/patryk/Zotero/storage/33SV2HHM/dslCatalog.html}
}

@book{fowler_domain-specific_2010,
  langid = {english},
  location = {{Upper Saddle River, NJ}},
  title = {Domain-{{Specific Languages}}},
  edition = {1 edition},
  isbn = {978-0-321-71294-3},
  abstract = {When carefully selected and used, Domain-Specific Languages (DSLs) may simplify complex code, promote effective communication with customers, improve productivity, and unclog development bottlenecks. In  Domain-Specific Languages , noted software development expert Martin Fowler first provides the information software professionals need to decide if and when to utilize DSLs. Then, where DSLs prove suitable, Fowler presents effective techniques for building them, and guides software engineers in choosing the right approaches for their applications.    This book’s techniques may be utilized with most modern object-oriented languages; the author provides numerous examples in Java and C\#, as well as selected examples in Ruby. Wherever possible, chapters are organized to be self-standing, and most reference topics are presented in a familiar patterns format.  Armed with this wide-ranging book, developers will have the knowledge they need to make important decisions about DSLs—and, where appropriate, gain the significant technical and business benefits they offer.  ~ The topics covered include: •~~~~~ How DSLs compare to frameworks and libraries, and when those alternatives are sufficient •~~~~~ Using parsers and parser generators, and parsing external DSLs •~~~~~ Understanding, comparing, and choosing DSL language constructs  •~~~~~ Determining whether to use code generation, and comparing code generation strategies •~~~~~ Previewing new language workbench tools for creating DSLs},
  pagetotal = {640},
  publisher = {{Addison-Wesley Professional}},
  date = {2010-10-03},
  author = {Fowler, Martin},
  file = {/home/patryk/Zotero/storage/EYFS8SJT/Fowler - Domain-Specific Languages.pdf}
}

@article{courtes_functional_2013,
  archivePrefix = {arXiv},
  eprinttype = {arxiv},
  eprint = {1305.4584},
  primaryClass = {cs},
  langid = {english},
  title = {Functional {{Package Management}} with {{Guix}}},
  url = {http://arxiv.org/abs/1305.4584},
  abstract = {We describe the design and implementation of GNU Guix, a purely functional package manager designed to support a complete GNU/Linux distribution. Guix supports transactional upgrades and roll-backs, unprivileged package management, per-user proﬁles, and garbage collection. It builds upon the low-level build and deployment layer of the Nix package manager. Guix uses Scheme as its programming interface. In particular, we devise an embedded domain-speciﬁc language (EDSL) to describe and compose packages. We demonstrate how it allows us to beneﬁt from the host general-purpose programming language while not compromising on expressiveness. Second, we show the use of Scheme to write build programs, leading to a “two-tier” programming system.},
  urldate = {2019-01-15},
  date = {2013-05-20},
  keywords = {Computer Science - Programming Languages},
  author = {Courtès, Ludovic},
  file = {/home/patryk/Zotero/storage/AZUACYXL/Courtès - 2013 - Functional Package Management with Guix.pdf}
}

@online{neidhardt_guix_2019,
  title = {Guix: {{A}} Most Advanced Operating System},
  url = {https://ambrevar.xyz/guix-advance/index.html},
  urldate = {2019-01-15},
  date = {2019},
  author = {Neidhardt, Pierre},
  file = {/home/patryk/Zotero/storage/BZGH792B/index.html}
}

@thesis{dolstra_purely_2006,
  langid = {english},
  location = {{S.l.}},
  title = {The Purely Functional Software Deployment Model},
  institution = {{[s.n.]}},
  date = {2006},
  author = {Dolstra, Eelco},
  file = {/home/patryk/Zotero/storage/3X5BTN7Q/Dolstra - 2006 - The purely functional software deployment model.pdf},
  note = {OCLC: 71702886}
}

@article{hudak_report_1992,
  title = {Report on the {{Programming Language Haskell}}: {{A Non}}-Strict, {{Purely Functional Language Version}} 1.2},
  volume = {27},
  issn = {0362-1340},
  url = {http://doi.acm.org/10.1145/130697.130699},
  doi = {10.1145/130697.130699},
  shorttitle = {Report on the {{Programming Language Haskell}}},
  abstract = {"Some half dozen persons have written technically on combinatory logic, and most of these, including ourselves, have published something erroneous. Since some of our fellow sinners are among the most careful and competent logicians on the contemporary scene, we regard this as evidence that the subject is refractory. Thus fullness of exposition is necessory for accurary; and excessive condensation would be false economy here, even more than it is ordinarily."},
  number = {5},
  journaltitle = {SIGPLAN Not.},
  urldate = {2019-01-15},
  date = {1992-05},
  pages = {1--164},
  author = {Hudak, Paul and Peyton Jones, Simon and Wadler, Philip and Boutel, Brian and Fairbairn, Jon and Fasel, Joseph and Guzmán, María M. and Hammond, Kevin and Hughes, John and Johnsson, Thomas and Kieburtz, Dick and Nikhil, Rishiyur and Partain, Will and Peterson, John}
}

@online{gnu_download_2019,
  title = {Download — {{GuixSD}}},
  url = {https://www.gnu.org/software/guix/download/},
  urldate = {2019-01-15},
  date = {2019},
  author = {{GNU}},
  file = {/home/patryk/Zotero/storage/TFVWESF8/download.html}
}

@online{sterlind_guix_2019,
  title = {Guix: {{An}} Advanced Operating System | {{Hacker News}}},
  url = {https://news.ycombinator.com/item?id=18902823},
  urldate = {2019-01-15},
  date = {2019},
  author = {{Sterlind}},
  file = {/home/patryk/Zotero/storage/SSABL3HJ/item.html}
}

@inproceedings{dolstra_nixos_2008,
  location = {{New York, NY, USA}},
  title = {{{NixOS}}: {{A Purely Functional Linux Distribution}}},
  isbn = {978-1-59593-919-7},
  url = {http://doi.acm.org/10.1145/1411204.1411255},
  doi = {10.1145/1411204.1411255},
  shorttitle = {{{NixOS}}},
  abstract = {Existing package and system configuration management tools suffer from an imperative model, where system administration actions such as upgrading packages or changes to system configuration files are stateful: they destructively update the state of the system. This leads to many problems, such as the inability to roll back changes easily, to run multiple versions of a package side-by-side, to reproduce a configuration deterministically on another machine, or to reliably upgrade a system. In this paper we show that we can overcome these problems by moving to a purely functional system configuration model. This means that all static parts of a system (such as software packages, configuration files and system startup scripts) are built by pure functions and are immutable, stored in a way analogously to a heap in a purely function language. We have implemented this model in NixOS, a non-trivial Linux distribution that uses the Nix package manager to build the entire system configuration from a purely functional specification.},
  booktitle = {Proceedings of the 13th {{ACM SIGPLAN International Conference}} on {{Functional Programming}}},
  series = {{{ICFP}} '08},
  publisher = {{ACM}},
  urldate = {2019-01-15},
  date = {2008},
  pages = {367--378},
  keywords = {nix,NixOS,package management,purely functional deployment model,purely functional language,software deployment,system configuration management},
  author = {Dolstra, Eelco and Löh, Andres},
  file = {/home/patryk/Zotero/storage/5EDMPELH/Dolstra et Loh - NixOS A Purely Functional Linux Distribution.pdf}
}

@online{prins_creating_2019,
  langid = {english},
  title = {Creating a Reproducible Workflow with {{CWL}}},
  url = {https://gitlab.com/pjotrp/guix-notes/blob/master/WORKFLOW.org},
  abstract = {Notes on Guix},
  journaltitle = {GitLab},
  urldate = {2019-01-15},
  date = {2019},
  author = {Prins, Pjotr},
  file = {/home/patryk/Zotero/storage/RRNM34U3/WORKFLOW.html}
}

@inproceedings{wadler_essence_1992,
  langid = {english},
  location = {{Albuquerque, New Mexico, United States}},
  title = {The Essence of Functional Programming},
  isbn = {978-0-89791-453-6},
  url = {http://portal.acm.org/citation.cfm?doid=143165.143169},
  doi = {10.1145/143165.143169},
  abstract = {This paper explores the use monads to structure functional programs. No prior knowledge of monads or category theory is required. Monads increase the ease with which programs may be modi ed. They can mimic the e ect of impure features such as exceptions, state, and continuations; and also provide e ects not easily achieved with such features. The types of a program re ect which e ects occur.},
  eventtitle = {The 19th {{ACM SIGPLAN}}-{{SIGACT}} Symposium},
  booktitle = {Proceedings of the 19th {{ACM SIGPLAN}}-{{SIGACT}} Symposium on {{Principles}} of Programming Languages  - {{POPL}} '92},
  publisher = {{ACM Press}},
  urldate = {2019-01-16},
  date = {1992},
  pages = {1-14},
  author = {Wadler, Philip},
  file = {/home/patryk/Zotero/storage/L5JC8S57/Wadler - 1992 - The essence of functional programming.pdf}
}

@online{wikibooks_haskell_2017,
  title = {Haskell - {{Wikibooks}}, Biblioteka Wolnych Podręczników},
  url = {https://pl.wikibooks.org/wiki/Haskell#Haskell_vs_OOP_(Programowanie_obiektowe)},
  urldate = {2019-01-16},
  date = {2017},
  author = {{Wikibooks}},
  file = {/home/patryk/Zotero/storage/5I8HQGKN/Haskell.html}
}

@book{backfield_becoming_2014,
  langid = {english},
  title = {Becoming {{Functional}}: {{Steps}} for {{Transforming Into}} a {{Functional Programmer}}},
  isbn = {978-1-4919-4751-7},
  shorttitle = {Becoming {{Functional}}},
  abstract = {If you have an imperative (and probably object-oriented) programming background, this hands-on book will guide you through the alien world of functional programming. Author Joshua Backfield begins slowly by showing you how to apply the most useful implementation concepts before taking you further into functional-style concepts and practices.In each chapter, you’ll learn a functional concept and then use it to refactor the fictional XXY company’s imperative-style legacy code, writing and testing the functional code yourself. As you progress through the book, you’ll migrate from Java 7 to Groovy and finally to Scala as the need for better functional language support gradually increases.Learn why today’s finely tuned applications work better with functional codeTransform imperative-style patterns into functional code, following basic stepsGet up to speed with Groovy and Scala through examplesUnderstand how first-class functions are passed and returned from other functionsConvert existing methods into pure functions, and loops into recursive methodsChange mutable variables into immutable variablesGet hands-on experience with statements and nonstrict evaluationsUse functional programming alongside object-oriented design},
  pagetotal = {151},
  publisher = {{"O'Reilly Media, Inc."}},
  date = {2014-07-02},
  keywords = {Computers / General,Computers / Programming / General,Computers / Programming / Open Source,Computers / Programming Languages / C,Computers / Programming Languages / General,Computers / Programming Languages / Java,Computers / Programming Languages / JavaScript},
  author = {Backfield, Joshua},
  eprinttype = {googlebooks}
}

@inproceedings{molina-markham_private_2010,
  langid = {english},
  location = {{Zurich, Switzerland}},
  title = {Private Memoirs of a Smart Meter},
  isbn = {978-1-4503-0458-0},
  url = {http://portal.acm.org/citation.cfm?doid=1878431.1878446},
  doi = {10.1145/1878431.1878446},
  abstract = {Household smart meters that measure power consumption in real-time at ﬁne granularities are the foundation of a future smart electricity grid. However, the widespread deployment of smart meters has serious privacy implications since they inadvertently leak detailed information about household activities. In this paper, we show that even without a priori knowledge of household activities or prior training, it is possible to extract complex usage patterns from smart meter data using off-the-shelf statistical methods. Our analysis uses two months of data from three homes, which we instrumented to log aggregate household power consumption every second. With the data from our small-scale deployment, we demonstrate the potential for power consumption patterns to reveal a range of information, such as how many people are in the home, sleeping routines, eating routines, etc. We then sketch out the design of a privacy-enhancing smart meter architecture that allows an electric utility to achieve its net metering goals without compromising the privacy of its customers.},
  eventtitle = {The 2nd {{ACM Workshop}}},
  booktitle = {Proceedings of the 2nd {{ACM Workshop}} on {{Embedded Sensing Systems}} for {{Energy}}-{{Efficiency}} in {{Building}} - {{BuildSys}} '10},
  publisher = {{ACM Press}},
  urldate = {2019-01-17},
  date = {2010},
  pages = {61},
  author = {Molina-Markham, Andrés and Shenoy, Prashant and Fu, Kevin and Cecchet, Emmanuel and Irwin, David},
  file = {/home/patryk/Zotero/storage/KD9JNVBV/Molina-Markham et al. - 2010 - Private memoirs of a smart meter.pdf}
}

@online{owens_legion_2017,
  title = {Legion: {{Distributed}}, Stateful, Homogeneous Microservice Framework.},
  url = {http://hackage.haskell.org/package/legion},
  urldate = {2019-01-17},
  date = {2017},
  author = {Owens, Rick},
  file = {/home/patryk/Zotero/storage/36GADIJA/legion.html}
}

@article{zuerey_smartmetering_nodate,
  langid = {english},
  title = {{{SmartMetering Data Analysis}} by {{Machine Learning Techniques}}},
  pages = {121},
  author = {Zuﬀerey, Thierry},
  file = {/home/patryk/Zotero/storage/JD8XB4QR/Zuﬀerey - SmartMetering Data Analysis by Machine Learning Te.pdf}
}

@article{liu_smart_2016,
  title = {Smart {{Meter Data Analytics}}: {{Systems}}, {{Algorithms}} and {{Benchmarking}}},
  volume = {42},
  issn = {0362-5915},
  url = {http://tods.acm.org/},
  doi = {10.1145/3004295},
  shorttitle = {Smart {{Meter Data Analytics}}},
  abstract = {Smart electricity meters have been replacing conventional meters worldwide, enabling automated collection of fine-grained (e.g., every 15 minutes or hourly) consumption data. A variety of smart meter analytics algorithms and applications have been proposed, mainly in the smart grid literature. However, the focus has been on what can be done with the data rather than how to do it efficiently. In this paper, we examine smart meter analytics from a software performance perspective. First, we design a performance benchmark that includes common smart meter analytics tasks. These include off-line feature extraction and model building as well a framework for on-line anomaly detection that we propose. Second, since obtaining real smart meter data is difficult due to privacy issues, we present an algorithm for generating large realistic data sets from a small seed of real data. Third, we implement the proposed benchmark using five representative platforms: a traditional numeric computing platform (Matlab), a relational DBMS with a built-in machine learning toolkit (PostgreSQL/MADlib), a main-memory column store (“System C”), and two distributed data processing platforms (Hive and Spark/Spark Streaming). We compare the five platforms in terms of application development effort and performance on a multicore machine as well as a cluster of 16 commodity servers.},
  number = {1},
  journaltitle = {A C M Transactions on Database Systems},
  shortjournal = {A C M Transactions on Database Systems},
  urldate = {2019-01-18},
  date = {2016},
  author = {Liu, Xiufeng and Golab, Lukasz and Golab, Wojciech and Ilyas, Ihab F. and Jin, Shichao},
  file = {/home/patryk/Zotero/storage/XNRKFBHM/(PDF) Smart Meter Data Analytics Systems, Algorit.pdf}
}

@inproceedings{liu_smas_2015,
  langid = {english},
  location = {{Seoul, South Korea}},
  title = {{{SMAS}}: {{A}} Smart Meter Data Analytics System},
  isbn = {978-1-4799-7964-6},
  url = {http://ieeexplore.ieee.org/document/7113405/},
  doi = {10.1109/ICDE.2015.7113405},
  shorttitle = {{{SMAS}}},
  abstract = {Smart electricity meters are replacing conventional meters worldwide and have enabled a new application domain: smart meter data analytics. In this paper, we introduce SMAS, our smart meter analytics system, which demonstrates the actionable insight that consumers and utilities can obtain from smart meter data. Notably, we implemented SMAS inside a relational database management system using open source tools: PostgreSQL and the MADLib machine learning toolkit. In the proposed demonstration, conference attendees will interact with SMAS as electricity providers, consultants and consumers, and will perform various analyses on real data sets.},
  eventtitle = {2015 {{IEEE}} 31st {{International Conference}} on {{Data Engineering}} ({{ICDE}})},
  booktitle = {2015 {{IEEE}} 31st {{International Conference}} on {{Data Engineering}}},
  publisher = {{IEEE}},
  urldate = {2019-01-18},
  date = {2015-04},
  pages = {1476-1479},
  author = {Liu, Xiufeng and Golab, Lukasz and Ilyas, Ihab F.},
  file = {/home/patryk/Zotero/storage/RMB4IHYU/Liu et al. - 2015 - SMAS A smart meter data analytics system.pdf}
}

@software{liu_smart_2015,
  title = {Smart {{Meter Data Analysis System}}. {{Contribute}} to Xiufengliu/{{SMAS}} Development by Creating an Account on {{GitHub}}},
  url = {https://github.com/xiufengliu/SMAS},
  urldate = {2019-01-18},
  date = {2015},
  author = {Liu, Xiufeng},
  origdate = {2014-10-14T21:26:52Z}
}

@online{visual_paradigm_archimate_nodate,
  title = {{{ArchiMate Diagram Tutorial}}},
  url = {https://online.visual-paradigm.com/tutorials/archimate-tutorial/#full-togaf-adm-in-archimate-3},
  urldate = {2019-01-18},
  author = {{Visual Paradigm}},
  file = {/home/patryk/Zotero/storage/3SLBW7ED/archimate-tutorial.html}
}

@book{gamma_design_1994,
  langid = {english},
  title = {Design {{Patterns}}: {{Elements}} of {{Reusable Object}}-{{Oriented Software}}},
  isbn = {978-0-321-70069-8},
  shorttitle = {Design {{Patterns}}},
  abstract = {Capturing a wealth of experience about the design of object-oriented software, four top-notch designers present a catalog of simple and succinct solutions to commonly occurring design problems. Previously undocumented, these 23 patterns allow designers to create more flexible, elegant, and ultimately reusable designs without having to rediscover the design solutions themselves. The authors begin by describing what patterns are and how they can help you design object-oriented software. They then go on to systematically name, explain, evaluate, and catalog recurring designs in object-oriented systems. With Design Patterns as your guide, you will learn how these important patterns fit into the software development process, and how you can leverage them to solve your own design problems most efficiently. Each pattern describes the circumstances in which it is applicable, when it can be applied in view of other design constraints, and the consequences and trade-offs of using the pattern within a larger design. All patterns are compiled from real systems and are based on real-world examples. Each pattern also includes code that demonstrates how it may be implemented in object-oriented programming languages like C++ or Smalltalk.},
  pagetotal = {457},
  publisher = {{Pearson Education}},
  date = {1994-10-31},
  keywords = {Computers / Computer Vision & Pattern Recognition},
  author = {Gamma, Erich and Helm, Richard and Johnson, Ralph and Vlissides, John},
  file = {/home/patryk/Zotero/storage/QCBTQ2ZK/Gamma et al. - 1994 - Design Patterns Elements of Reusable Object-Orien.pdf},
  eprinttype = {googlebooks}
}

@video{feynman_take_1973,
  title = {Take the {{World}} from {{Another Point}} of {{View}}},
  url = {http://calteches.library.caltech.edu/35/2/PointofView.htm},
  urldate = {2019-01-20},
  date = {1973},
  director = {Feynman, Richard},
  file = {/home/patryk/Zotero/storage/5AKRQZDQ/PointofView.html}
}

@book{raymond_art_2003,
  langid = {english},
  title = {The {{Art}} of {{UNIX Programming}}},
  isbn = {978-0-13-246588-5},
  abstract = {The Art of UNIX Programming  poses the belief that understanding the unwritten UNIX engineering tradition and mastering its design patterns will help programmers of all stripes to become better programmers. This book attempts to capture the engineering wisdom and design philosophy of the UNIX, Linux, and Open Source software development community as it has evolved over the past three decades, and as it is applied today by the most experienced programmers. Eric Raymond offers the next generation of "hackers" the unique opportunity to learn the connection between UNIX philosophy and practice through careful case studies of the very best UNIX/Linux programs.},
  pagetotal = {560},
  publisher = {{Addison-Wesley Professional}},
  date = {2003-09-23},
  keywords = {Computers / Operating Systems / Linux,Computers / Operating Systems / UNIX},
  author = {Raymond, Eric S.}
}

@book{milewski_category_2018,
  langid = {english},
  title = {Category {{Theory}} for {{Programmers}}},
  url = {http://www.blurb.com/b/9008339-category-theory-for-programmers},
  abstract = {Category Theory is one of the most abstract branches of mathematics. It is usually taught to graduate students after they have mastered several other branches of mathematics, like algebra, topology, and group theory. It might therefore come as a shock that the basic concepts of category theory can be explained in relatively simple terms to anybody with some experience in programming.

That's because, just like programming, category theory is about structure. Mathematicians discover structure in mathematical theories, programmers discover structure in computer programs. Well structured programs are easier to understand and maintain, and are less likely to contain bugs. Category theory provides the language to talk about structure, and learning it will make you a better programmer.},
  publisher = {{University of Texas}},
  urldate = {2019-01-20},
  date = {2018},
  author = {Milewski, Bartosz},
  file = {/home/patryk/Zotero/storage/6XQ28MWB/9008339-category-theory-for-programmers.html}
}

@incollection{andrews_churchs_2018,
  title = {Church's {{Type Theory}}},
  edition = {Summer 2018},
  url = {https://plato.stanford.edu/archives/sum2018/entriesype-theory-church/},
  abstract = {Church's type theory is a formal logical language which includes first-order logic, but is moreexpressive in a practical sense. It is used, with some modificationsand enhancements, in most modern applications of type theory. It isparticularly well suited to the formalization of mathematics andother disciplines and to specifying and verifying hardware andsoftware.  It also plays an important role in thestudy of the formal semantics of natural language., A great wealth of technical knowledge can be expressedvery naturally in it.  With possible enhancements, Church's typetheory constitutes an excellent formal language for representing theknowledge in automated information systems, sophisticated  automated reasoning systems, systems forverifying the correctness of mathematical proofs, and certain projects involving logic and artificial intelligence. Some examples are given in Section 1.2.2 below., Type theories are also called higher-order logics, since they allowquantification not only over individual variables (as in first-orderlogic), but also over function, predicate, and even higher ordervariables.  Type theories characteristically assign types to entities,distinguishing, for example, between numbers, set of numbers,functions from numbers to sets of numbers, and sets of such functions.As illustrated in Section 1.2.2 below, these distinctions allow one todiscuss the conceptually rich world of sets and functions withoutencountering the paradoxes of naive set theory., Church's type theory is a formulation of  type theory that was introduced by Alonzo Church in Church 1940. In certainrespects, it is simpler and more general than the type theoryintroduced by Bertrand Russell in Russell 1908 and Whitehead \& Russell 1927a. Sinceproperties and relations can be regarded as functions from entities totruth values, the concept of a function is taken as primitive inChurch's type theory, and the λ-notation which Churchintroduced in Church 1932 and Church 1941 is incorporated into the formallanguage.},
  booktitle = {The {{Stanford Encyclopedia}} of {{Philosophy}}},
  publisher = {{Metaphysics Research Lab, Stanford University}},
  urldate = {2019-01-20},
  date = {2018},
  keywords = {artificial intelligence: logic and,logic: classical,reasoning: automated,Russell; Bertrand,type theory},
  author = {Andrews, Peter},
  editor = {Zalta, Edward N.}
}

@article{church_formulation_1940,
  langid = {english},
  title = {A Formulation of the Simple Theory of Types},
  volume = {5},
  issn = {0022-4812, 1943-5886},
  url = {https://www.cambridge.org/core/journals/journal-of-symbolic-logic/article/formulation-of-the-simple-theory-of-types/85B3666C7DD81A4F66966A399364B44B},
  doi = {10.2307/2266170},
  abstract = {The purpose of the present paper is to give a formulation of the simple theory of types which incorporates certain features of the calculus of λ-conversion. A complete incorporation of the calculus of λ-conversion into the theory of types is impossible if we require that λx and juxtaposition shall retain their respective meanings as an abstraction operator and as denoting the application of function to argument. But the present partial incorporation has certain advantages from the point of view of type theory and is offered as being of interest on this basis (whatever may be thought of the finally satisfactory character of the theory of types as a foundation for logic and mathematics).For features of the formulation which are not immediately connected with the incorporation of λ-conversion, we are heavily indebted to Whitehead and Russell, Hilbert and Ackermann, Hilbert and Bernays, and to forerunners of these, as the reader familiar with the works in question will recognize.The class of type symbols is described by the rules that ı and o are each type symbols and that if α and β are type symbols then (αβ) is a type symbol: it is the least class of symbols which contains the symbols ı and o and is closed under the operation of forming the symbol (αβ) from the symbols α and β.},
  number = {2},
  journaltitle = {The Journal of Symbolic Logic},
  urldate = {2019-01-20},
  date = {1940-06},
  pages = {56-68},
  author = {Church, Alonzo},
  file = {/home/patryk/Zotero/storage/EAIMDYQ8/85B3666C7DD81A4F66966A399364B44B.html}
}


